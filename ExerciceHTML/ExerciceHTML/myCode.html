#include<iostream>#include<fstream>#include<vector>#include<string>#include<map>#include<regex>#include<algorithm>#include<sstream>usingnamespacestd;voidAddSpanToKeywords(string&content){vector<string>keywords=vector<string>{"alignas","alignof","and","and_eq","asm","auto","bitand","bitor","bool","break","case","catch","char","char16_t","char32_t","class","compl","concept","const","constexpr","const_cast","continue","decltype","default","delete","do","double","dynamic_cast","else","enum","explicit","export","extern","false","float","for","friend","goto","if","inline","int","long","mutable","namespace","new","noexcept","not","not_eq","nullptr","operator","or","or_eq","private","protected","public","register","reinterpret_cast","requires","return","short","signed","sizeof","static","static_assert","static_cast","struct","switch","template","this","thread_local","throw","true","try","typedef","typeid","typename","union","unsigned","using","virtual","void","volatile","wchar_t","while","xor","xor_eq"};stringretour="";booltrouve=false;for(inti=0;i&ltcontent.size();i++){if(keywords.at(i)==content&&!trouve){trouve=true;retour+="<spanstyle='color:blue'>"+content+"</span>";}}}//voidAddSpanToKeywords(string&content,stringkeyword)//{//autoword=content.find(keyword);//stringoldContent=content;//if(word!=std::string::npos)//{//content=oldContent.substr(0,word);//content+="<spanstyle='color:blue'>"+keyword+"</span>";//content+=oldContent.substr(word+keyword.length(),oldContent.length());//}//}voidAddWhiteSpaces(string&content){autoword=content.find('\t');stringoldContent=content;if(word!=std::string::npos){content=oldContent.substr(0,word);content+="&nbsp&nbsp&nbsp&nbsp";content+=oldContent.substr(word+1,oldContent.length());}}voidRemplacerTout(vector<string>&ampwords){for(inti=0;i!=words.size();++i){if(words[i]=="<"){words[i]="&lt";i+=2;}elseif(words[i]==">"){words[i]="&gt";i+=2;}elseif(words[i]=="&"){words[i]="&amp";i+=2;}elseif(words[i]=="\n"){words[i]="</br>";i+=4;}elseif(words[i]=="\t"){words[i]="&nbsp&nbsp&nbsp&nbsp";i+=19;}}}intmain(){vector<string>keywords=vector<string>{"alignas","alignof","and","and_eq","asm","auto","bitand","bitor","bool","break","case","catch","char","char16_t","char32_t","class","compl","concept","const","constexpr","const_cast","continue","decltype","default","delete","do","double","dynamic_cast","else","enum","explicit","export","extern","false","float","for","friend","goto","if","inline","int","long","mutable","namespace","new","noexcept","not","not_eq","nullptr","operator","or","or_eq","private","protected","public","register","reinterpret_cast","requires","return","short","signed","sizeof","static","static_assert","static_cast","struct","switch","template","this","thread_local","throw","true","try","typedef","typeid","typename","union","unsigned","using","virtual","void","volatile","wchar_t","while","xor","xor_eq"};ofstreamoutfile;stringstreamss;//stringpattern("[a-zA-Z_]([a-zA-Z0-9_])*");//regexexpression(pattern);ifstreaminfile("Source.cpp");if(infile){ss<<infile.rdbuf();infile.close();}vector<string>words;copy(istream_iterator<string>(ss),istream_iterator<string>(),back_inserter(words));RemplacerTout(words);//AddWhiteSpaces(words);stringcontent;for(autoconst&s:words){content+=s;}outfile.open("myCode.html");outfile<<content;outfile.close();}