#include<iostream>#include<fstream>#include<vector>#include<string>#include<map>#include<regex>#include<algorithm><span style='color:blue'>using</span><span style='color:blue'>namespace</span>std;stringAddSpanToKeywords(map<int,string>content){vector<string>keywords=vector<string>{"alignas","alignof","and","and_eq","asm","auto","bitand","bitor","bool","break","case","catch","char","char16_t","char32_t","class","compl","concept","const","constexpr","const_cast","continue","decltype","default","delete","do","double","dynamic_cast","else","enum","explicit","export","extern","false","float","for","friend","goto","if","inline","int","long","mutable","namespace","new","noexcept","not","not_eq","nullptr","operator","or","or_eq","private","protected","public","register","reinterpret_cast","requires","return","short","signed","sizeof","static","static_assert","static_cast","struct","switch","template","this","thread_local","throw","true","try","typedef","typeid","typename","union","unsigned","using","virtual","void","volatile","wchar_t","while","xor","xor_eq"};stringretour="";<span style='color:blue'>for</span>(inti=0;i<content.size();++i){<span style='color:blue'>bool</span>trouve=false;<span style='color:blue'>for</span>(intj=0;j<keywords.size();j++){<span style='color:blue'>if</span>(keywords.at(j)==content[i]&&!trouve){trouve=true;retour+="<spanstyle='color:blue'>"+content[i]+"</span>";}}<span style='color:blue'>if</span>(!trouve){retour+=content[i];}}<span style='color:blue'>return</span>retour;}<span style='color:blue'>void</span>AddWhiteSpaces(string&content){<span style='color:blue'>auto</span>word=content.find('\t');stringoldContent=content;<span style='color:blue'>if</span>(word!=std::string::npos){content=oldContent.substr(0,word);content+="&nbsp&nbsp&nbsp&nbsp";content+=oldContent.substr(word+1,oldContent.length());}}<span style='color:blue'>void</span>RemplacerTout(string&content){<span style='color:blue'>for</span>(inti=0;i!=content.size();++i){<span style='color:blue'>if</span>(content[i]=='<'){content.replace(i,1,"&lt");i+=2;}<span style='color:blue'>else</span><span style='color:blue'>if</span>(content[i]=='>'){content.replace(i,1,"&gt");i+=2;}<span style='color:blue'>else</span><span style='color:blue'>if</span>(content[i]=='&'){content.replace(i,1,"&amp");i+=2;}<span style='color:blue'>else</span><span style='color:blue'>if</span>(content[i]=='\n'){content.replace(i,1,"</br>");i+=4;}<span style='color:blue'>else</span><span style='color:blue'>if</span>(content[i]=='\t'){content.replace(i,1,"&nbsp&nbsp&nbsp&nbsp");i+=19;}}}<span style='color:blue'>int</span>main(){map<string,int>words;vector<string>keywords=vector<string>{"alignas","alignof","and","and_eq","asm","auto","bitand","bitor","bool","break","case","catch","char","char16_t","char32_t","class","compl","concept","const","constexpr","const_cast","continue","decltype","default","delete","do","double","dynamic_cast","else","enum","explicit","export","extern","false","float","for","friend","goto","if","inline","int","long","mutable","namespace","new","noexcept","not","not_eq","nullptr","operator","or","or_eq","private","protected","public","register","reinterpret_cast","requires","return","short","signed","sizeof","static","static_assert","static_cast","struct","switch","template","this","thread_local","throw","true","try","typedef","typeid","typename","union","unsigned","using","virtual","void","volatile","wchar_t","while","xor","xor_eq"};ifstreaminfile;ofstreamoutfile;stringcontent;stringpattern("[a-zA-Z_]([a-zA-Z0-9_])*");regexexpression(pattern);map<int,string>mots;<span style='color:blue'>int</span>i=0;infile.open("Source.cpp");<span style='color:blue'>for</span>(strings;infile>>s;){mots[i]=s;++i;}/*while(!infile.eof()){<span style='color:blue'>char</span>c=infile.get();content+=c;}*/RemplacerTout(content);content=AddSpanToKeywords(mots);AddWhiteSpaces(content);outfile.open("myCode.html");outfile<<content;}